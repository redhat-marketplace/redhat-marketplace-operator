package rectest

// Code generated by github.com/launchdarkly/go-options.  DO NOT EDIT.

import "fmt"

import (
	"sigs.k8s.io/controller-runtime/pkg/client"
)

import "github.com/google/go-cmp/cmp"

type ApplyGetStepOptionFunc func(c *getStepOptions) error

func (f ApplyGetStepOptionFunc) apply(c *getStepOptions) error {
	return f(c)
}

func newGetStepOptions(options ...GetStepOption) (getStepOptions, error) {
	var c getStepOptions
	err := applyGetStepOptionsOptions(&c, options...)
	return c, err
}

func applyGetStepOptionsOptions(c *getStepOptions, options ...GetStepOption) error {
	c.Labels = map[string]string{}
	c.CheckResult = Ignore
	for _, o := range options {
		if err := o.apply(c); err != nil {
			return err
		}
	}
	return nil
}

type GetStepOption interface {
	apply(*getStepOptions) error
}

type getWithNamespacedNameImpl struct {
	Name      string
	Namespace string
}

func (o getWithNamespacedNameImpl) apply(c *getStepOptions) error {
	c.NamespacedName.Name = o.Name
	c.NamespacedName.Namespace = o.Namespace
	return nil
}

func (o getWithNamespacedNameImpl) Equal(v getWithNamespacedNameImpl) bool {
	switch {
	case !cmp.Equal(o.Name, v.Name):
		return false
	case !cmp.Equal(o.Namespace, v.Namespace):
		return false
	}
	return true
}

func (o getWithNamespacedNameImpl) String() string {
	name := "GetWithNamespacedName"

	type stripped getWithNamespacedNameImpl
	value := stripped(o)
	return fmt.Sprintf("%s: %+v", name, value)
}

func GetWithNamespacedName(Name string, Namespace string) GetStepOption {
	return getWithNamespacedNameImpl{
		Name:      Name,
		Namespace: Namespace,
	}
}

type getWithObjImpl struct {
	o client.Object
}

func (o getWithObjImpl) apply(c *getStepOptions) error {
	c.Obj = o.o
	return nil
}

func (o getWithObjImpl) Equal(v getWithObjImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o getWithObjImpl) String() string {
	name := "GetWithObj"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func GetWithObj(o client.Object) GetStepOption {
	return getWithObjImpl{
		o: o,
	}
}

type getWithLabelsImpl struct {
	o map[string]string
}

func (o getWithLabelsImpl) apply(c *getStepOptions) error {
	c.Labels = o.o
	return nil
}

func (o getWithLabelsImpl) Equal(v getWithLabelsImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o getWithLabelsImpl) String() string {
	name := "GetWithLabels"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func GetWithLabels(o map[string]string) GetStepOption {
	return getWithLabelsImpl{
		o: o,
	}
}

type getWithCheckResultImpl struct {
	o ReconcilerTestValidationFunc
}

func (o getWithCheckResultImpl) apply(c *getStepOptions) error {
	c.CheckResult = o.o
	return nil
}

func (o getWithCheckResultImpl) Equal(v getWithCheckResultImpl) bool {
	switch {
	case !cmp.Equal(o.o, v.o):
		return false
	}
	return true
}

func (o getWithCheckResultImpl) String() string {
	name := "GetWithCheckResult"

	// hack to avoid go vet error about passing a function to Sprintf
	var value interface{} = o.o
	return fmt.Sprintf("%s: %+v", name, value)
}

func GetWithCheckResult(o ReconcilerTestValidationFunc) GetStepOption {
	return getWithCheckResultImpl{
		o: o,
	}
}
